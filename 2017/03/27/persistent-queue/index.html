<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>不可变队列的实现 | A Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-80224793-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">不可变队列的实现</h1><a id="logo" href="/.">A Blog</a><p class="description">by ylgrgyq</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">不可变队列的实现</h1><div class="post-meta">Mar 27, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>命令式语言中一般实现 Queue 就是用一个链表或数组做存储，之后有两个引用 Head 和 Tail 分别指向队首和队尾。一般为了方便判断队列是否为空还会引入一个哑元，Head 引用 不直接指向队列内的第一个元素而是指向这个哑元。具体细节可以参看各种数据结构相关的介绍。</p>
<p>不过在函数式语言下，各种数据结构都是不可变的，不会有个 Head、Tail 引用去指向队首队尾，并在每次有元素入队出队的时候被更新。在这种情况下该怎么实现 Queue 呢？</p>
<h1 id="两个-Stack-来实现-Queue"><a href="#两个-Stack-来实现-Queue" class="headerlink" title="两个 Stack 来实现 Queue"></a>两个 Stack 来实现 Queue</h1><p>以前遇到过这么一个面试题：怎么用两个 stack 去实现一个 queue？当时在做这个题的时候并没有想太多，只是把它当做一个思考题来做，但这个问题实际是对怎么在函数式语言下实现不可变队列有帮助的。</p>
<p>不可变队列实现的难点就是因为没有 Head、Tail 引用，用单个链表或数组在不考虑扩容的情况下，都是只能在队列的一端以 O(1) 的时间增加一个元素，但要从队列另一端取元素需要遍历整个队列导致时间复杂度变为 O(n)。这个时间复杂度并不符合我们的期待。而使用两个用链表实现的 Stack 去实现队列就能做到出入队平均时间复杂度都为 O(1)。注意是平均时间复杂度。</p>
<img src="/2017/03/27/persistent-queue/double-list.png" alt="两个 Stack 实现 Queue" title="两个 Stack 实现 Queue">
<p>如上图所示，用两个链表分别称为 Front 和 Rear。每次入队时，都将新元素添加到 Rear 链表中，这样时间为 O(1)。每次出队时，都从 Front 队列中取元素出队。如果 Front 非空，那么出队的时间复杂度为 O(1)，如果 Front 为空，则将 Rear 链表反转一下作为新的 Front 队列。之后再将新 Front 队列的队首元素出队，这个过程的时间复杂度为 O(n)。假设 Front 为空时 Rear 链表元素数量为 m，那么将 Rear 反转的时间是 O(m) 但之后 m 个元素出队时时间都是 O(1)，于是能将反转 Rear 队列的时间平摊给之后 m 次出队时间，所以平均下来出队操作的时间还是 O(1)。</p>
<p>这个过程用 Clojure 实现如下：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defrecord</span></span> Queue [front rear cnt])</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> make-queue</div><div class="line">  ([] (<span class="name">Queue.</span> '() '() <span class="number">0</span>))</div><div class="line">  ([front rear cnt]</div><div class="line">    (<span class="name">Queue.</span> front rear cnt)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn-</span></span> maintain [queue]</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">empty?</span></span> (<span class="name">.-front</span> queue)) (<span class="name">not-empty</span> (<span class="name">.-rear</span> queue)))</div><div class="line">    (<span class="name">make-queue</span> (<span class="name"><span class="builtin-name">reverse</span></span> (<span class="name">.-rear</span> queue)) '() (<span class="name">.-cnt</span> queue))</div><div class="line">    queue))</div><div class="line"></div><div class="line"><span class="comment">;; maintain after every enqueue to insure front list </span></div><div class="line"><span class="comment">;; must have at least one element when queue is not empty</span></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> enqueue [queue x]</div><div class="line">  (<span class="name">maintain</span> (<span class="name">make-queue</span> (<span class="name">.-front</span> queue) (<span class="name"><span class="builtin-name">conj</span></span> (<span class="name">.-rear</span> queue) x) (<span class="name"><span class="builtin-name">inc</span></span> (<span class="name">.-cnt</span> queue)))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> empty-queue? [queue]</div><div class="line">  (<span class="name"><span class="builtin-name">zero?</span></span> (<span class="name">.-cnt</span> queue)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> peek [queue]</div><div class="line">  (<span class="name"><span class="builtin-name">when-not</span></span> (<span class="name">empty-queue?</span> queue)</div><div class="line">    (<span class="name"><span class="builtin-name">first</span></span> (<span class="name">.-front</span> queue))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> dequeue [queue]</div><div class="line">  (<span class="name"><span class="builtin-name">if-not</span></span> (<span class="name">empty-queue?</span> queue)</div><div class="line">    (<span class="name">maintain</span> (<span class="name">make-queue</span> (<span class="name"><span class="builtin-name">rest</span></span> (<span class="name">.-front</span> queue)) (<span class="name">.-rear</span> queue) (<span class="name"><span class="builtin-name">dec</span></span> (<span class="name">.-cnt</span> queue))))</div><div class="line">    queue))</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>maintain 函数的作用主要是为了让队列非空时，Front 链表至少有一个元素存在。不然队列的 peek 操作在 Front 为空时需要遍历 Rear 链表才能找到下一个出队元素，并且由于 peek 的返回值只有下一个出队的元素，我们不能将新的队列结构返回(即反转 Rear 链表并将其作为 Front)，于是在连续执行 peek 操作时，每次 peek 都要遍历整个 Rear 表。这个是不合理的，所以我们需要保证队列非空时，Front 链表至少有一个元素存在，以供 peek 使用。</p>
<h1 id="Lazy-来实现真正-O-1-的队列"><a href="#Lazy-来实现真正-O-1-的队列" class="headerlink" title="Lazy 来实现真正 O(1) 的队列"></a>Lazy 来实现真正 O(1) 的队列</h1><p>上面实现的缺陷是显而易见的，虽然平均时间是 O(1) 但毕竟会存在某次出队的耗时为 O(n)，导致使用时每次出队操作时间有颠簸。而如果我们能借助函数式编程语言普遍支持的 Lazy 特性去实现队列，就能避免这种颠簸。</p>
<p>还是延续上面双链表的实现，最耗时的操作是反转 Rear 链表，每次执行这个操作的时间点是在 Front 队列为空的时候。如果我们不想只在这一个时间点进行 Rear 反转，想将反转过程平摊到每次出入队操作中，那么我们就需要在 Front 还未变为空的时候就执行 Rear 反转，并且每次都执行一小步，比如反转一个元素，从而保证每一个出入队操作的时间都是 O(1)。</p>
<p>但是 Front 链表非空时我们就反转 Rear 的话，反转完 Rear 时如果队列没有元素出队，那么 Front 链表是没有变动过的，那不可能像之前一样将反转后的 Rear 链表直接作为 Front 来使用，而是还需要将 Front 和反转后的 Rear 连接起来。Front 是链表，头部是队首，如下图所示，如果直接拼接的话还是要遍历 Front 链表找到 Front 链表的尾巴，再将尾巴指向反转后的 Rear 链表。</p>
<img src="/2017/03/27/persistent-queue/m-double-list.png" alt="Front 和 Rear 的拼接" title="Front 和 Rear 的拼接">
<p>如果 Rear 长度是 n，Front 长度是 m，那么反转 Rear 的操作要 n 步，连接 Front 的操作要 m 步。以连续入队操作来看，也就是说如果每次入队都执行一个 Rear 反转或者连接 Front 工作的话，连接完毕后 Rear 又会有 m + n 个元素了，我们为了每次入队都只执行一次额外操作，所以每一个入队操作都不能浪费，也就是说连接完毕之后再入队一个元素时我们又要开始下一轮反转 Rear 和连接 Front 的工作，此时 Front 长度为 m + n，Rear 长度为 m + n + 1，从而得到 Rear 反转和连接 Front 的工作每次是 Rear 比 Front 多一个元素的时候开始。</p>
<p>我们将反转 Rear 和连接 Front 两个工作称为 rotate，并且约定 rotate 执行时间为 Rear 比 Front 多一个元素时。我们得到 rotate 函数如下，注意 acc 表示的是反转 Rear 的结果，即 rotate 的反转 Rear 和连接 Front 操作最终都是构建在 acc 这个 List 上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// rotate 执行时必须保证 rear 比 front 多一个元素</div><div class="line">(defn rotate [front rear acc]</div><div class="line">  (lazy-seq</div><div class="line">    (if (empty? front)</div><div class="line">      // 如果 front 为空，那么 rear 只有一个元素，所以直接放入 acc</div><div class="line">      (cons (first rear) acc)</div><div class="line">      // 当 front 非空，下面解释</div><div class="line">      (cons (first front)</div><div class="line">            (rotate (rest front) (rest rear) (cons (first rear) acc))))))</div></pre></td></tr></table></figure>
<p>front 非空的情形直接这么看比较难理解，不过通过下面公式就好理解了：<br>rotate(X, Y, A) = X ++ reverse(Y) ++ A<br>                = x1 ++ (X’ ++ reverse(Y) ++ A)<br>                = x1 ++ X’ ++ reverse(Y’) ++ y1 ++ A<br>                = x1 ++ rotate(X’, Y’, y1 ++ A)</p>
<p>其中 x1 是 X 中的第一个元素，y1 是 Y 中的第一个元素。A 是用来存放 Rear 反转结果的。</p>
<p>rotate 的结果实际就是 Front，我们希望出队入队都能执行 Rear 反转或连接 Front，所以我们每次入队出队都要求 rotate 结果下一个值。所以单独拿一个叫做 rots 的 var 来存放 rotate 的结果，rots 和 front 共同指向 rotate 的结果，只是 rots 是用来每次出队入队时候求值的，front 仅仅在出队时使用，相当于 front 保存着队首元素，rots 只是为了求出整个队列，所以不需要保存队首元素。</p>
<p>使用 Clojure 实现如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defrecord</span></span> LazyQueue [front rear rots cnt])</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> make-queue</div><div class="line">  ([] (<span class="name">LazyQueue.</span> '() '() '() <span class="number">0</span>))</div><div class="line">  ([front rear rots cnt] (<span class="name">LazyQueue.</span> front rear rots cnt)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> rotate [front rear acc]</div><div class="line">  (<span class="name"><span class="builtin-name">lazy-seq</span></span> (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">empty?</span></span> front)</div><div class="line">              (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> rear) acc)</div><div class="line">              (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> front)</div><div class="line">                    (<span class="name">rotate</span> (<span class="name"><span class="builtin-name">rest</span></span> front) (<span class="name"><span class="builtin-name">rest</span></span> rear) (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> rear) acc))))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> maintain [queue]</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">empty?</span></span> (<span class="name">.-rots</span> queue))</div><div class="line">    (<span class="name"><span class="builtin-name">let</span></span> [rots (<span class="name">rotate</span> (<span class="name">.-front</span> queue) (<span class="name">.-rear</span> queue) '())]</div><div class="line">      (<span class="name">make-queue</span> rots '() rots (<span class="name">.-cnt</span> queue)))</div><div class="line">    (<span class="name">make-queue</span> (<span class="name">.-front</span> queue) (<span class="name">.-rear</span> queue) (<span class="name"><span class="builtin-name">rest</span></span> (<span class="name">.-rots</span> queue)) (<span class="name">.-cnt</span> queue))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> enqueue [queue x]</div><div class="line">  (<span class="name">maintain</span> (<span class="name">make-queue</span> (<span class="name">.-front</span> queue) (<span class="name"><span class="builtin-name">conj</span></span> (<span class="name">.-rear</span> queue) x) (<span class="name">.-rots</span> queue) (<span class="name"><span class="builtin-name">inc</span></span> (<span class="name">.-cnt</span> queue)))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> empty-queue? [queue]</div><div class="line">  (<span class="name"><span class="builtin-name">zero?</span></span> (<span class="name">.-cnt</span> queue)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> peek-queue [queue]</div><div class="line">  (<span class="name"><span class="builtin-name">when-not</span></span> (<span class="name">empty-queue?</span> queue)</div><div class="line">    (<span class="name"><span class="builtin-name">first</span></span> (<span class="name">.-front</span> queue))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> dequeue [queue]</div><div class="line">  (<span class="name">maintain</span> (<span class="name">make-queue</span> (<span class="name"><span class="builtin-name">rest</span></span> (<span class="name">.-front</span> queue)) (<span class="name">.-rear</span> queue) (<span class="name">.-rots</span> queue) (<span class="name"><span class="builtin-name">dec</span></span> (<span class="name">.-cnt</span> queue)))))</div></pre></td></tr></table></figure>
<p>那么 Clojure 中的 Queue 是怎么实现的呢？</p>
<h1 id="Clojure-中的-queue"><a href="#Clojure-中的-queue" class="headerlink" title="Clojure 中的 queue"></a>Clojure 中的 queue</h1><p>Clojure 中的 queue 一般是指 clojure.lang 中的 PersistentQueue，它使用起来可能会让人觉得有点怪，比如像这样：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">let</span></span> [queue (<span class="name"><span class="builtin-name">-&gt;</span></span> (<span class="name">PersistentQueue/EMPTY</span>)</div><div class="line">                (<span class="name"><span class="builtin-name">conj</span></span> <span class="number">1</span>)</div><div class="line">                (<span class="name"><span class="builtin-name">conj</span></span> <span class="number">2</span>)</div><div class="line">                (<span class="name"><span class="builtin-name">conj</span></span> <span class="number">3</span>))]</div><div class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [q queue]</div><div class="line">    (<span class="name"><span class="builtin-name">when-let</span></span> [x (<span class="name"><span class="builtin-name">peek</span></span> q)]</div><div class="line">      (<span class="name">println</span> x)</div><div class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">pop</span></span> q)))))</div></pre></td></tr></table></figure><br>它出队用的 peek 和 pop，让人感觉像个 stack 一样。用 first 和 rest 在一些场合下也行，first 使用起来跟 peek 效果相同，但 rest 会将队列转换为 list，从而失去 queue 的语义，转换成 list 之后再使用 conj 会将新元素加入到 list 首部。</p>
<p>PersistentQueue 实现方式跟前面说的两个 Stack 实现 Queue 有点类似，但里面 Front 是 List，Rear 是 PersistentVector。入队函数实现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public PersistentQueue cons(Object o)&#123;</div><div class="line">    if(f == null)     //empty</div><div class="line">        return new PersistentQueue(meta(), cnt + 1, RT.list(o), null);</div><div class="line">    else</div><div class="line">        return new PersistentQueue(meta(), cnt + 1, f, (r != null ? r : PersistentVector.EMPTY).cons(o));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到入队的时候也是直接放入 Rear，并且也是只要 Queue 不空则至少有一个元素再 Front 中。</p>
<p>出队函数如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public PersistentQueue pop()&#123;</div><div class="line">    if(f == null)  //hmmm... pop of empty queue -&gt; empty queue?</div><div class="line">        return this;</div><div class="line">    ISeq f1 = f.next();</div><div class="line">    PersistentVector r1 = r;</div><div class="line">    if(f1 == null)</div><div class="line">        &#123;</div><div class="line">        f1 = RT.seq(r);</div><div class="line">        r1 = null;</div><div class="line">        &#125;</div><div class="line">    return new PersistentQueue(meta(), cnt - 1, f1, r1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出队时从 Front 出队，如果出队完 Front 为空，则需要将 Rear 导入 Front。由于 Rear 是由 PersistentVector 实现的，每次添加元素是以接近 O(1) 的时间添加在 vector 末尾，所以其元素顺序和 Front 顺序相同，可以直接将 Rear 通过 seq 操作转化为 List 后作为 Front 即可，无需进行反转操作。因为 PersistentVector 能够以 O(1) 的时间访问任意一个元素，所以它只需要实现 ISeq 接口就能变成一个 List，不需要任何拷贝操作。</p>
<p>不需要反转，也不需要连接 Front (因为每次 Rear 变成 Front 时 Front 都是空的)，所以 PersistentQueue 不会出现“颠簸”，出队和入队基本都是 O(1) 的时间。</p>
<p>如此神奇的 PersistentVector 的实现可以看下<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" target="_blank" rel="external">这篇文章</a>。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://ylgrgyq.github.io/2017/03/27/persistent-queue/" data-id="cj5he6eo0000a58wxmvu0cfjq" class="article-share-link">Share</a><div class="tags"><a href="/tags/Clojure/">Clojure</a></div><div class="post-nav"><a href="/2017/04/01/basic-concurrent-queue/" class="pre">普通队列改造为并发队列</a><a href="/2016/07/17/found-a-bug-in-netty/" class="next">追踪 Netty 异常占用堆外内存的经验分享</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Bug/" style="font-size: 15px;">Bug</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/24/linux-receive-packet-2/">Linux 网络协议栈收消息过程-Per CPU Backlog</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/23/linux-receive-packet-1/">Linux 网络协议栈收消息过程-Ring Buffer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/RTM-max-connections/">实时通信系统并发连接数测试时需要调整的各种参数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/tcp-time-wait/">TCP TIME-WAIT</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/18/tcp-backlog/">TCP Backlog</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/14/tls-sni/">一次 TLS SNI 问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/01/basic-concurrent-queue/">普通队列改造为并发队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/27/persistent-queue/">不可变队列的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/17/found-a-bug-in-netty/">追踪 Netty 异常占用堆外内存的经验分享</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/03/garbage-first-collector-understanding/">Garbage First Collector 理解</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">A Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>