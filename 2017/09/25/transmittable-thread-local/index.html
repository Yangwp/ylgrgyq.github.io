<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>线程之间传递 ThreadLocal 对象 | A Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-80224793-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线程之间传递 ThreadLocal 对象</h1><a id="logo" href="/.">A Blog</a><p class="description">by ylgrgyq</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">线程之间传递 ThreadLocal 对象</h1><div class="post-meta">Sep 25, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>为了介绍线程间传递 ThreadLocal 对象这个事情，请先耐心一些跟我一起来看看我是怎么遇到线程间传递 ThreadLocal 对象这个需求的。</p>
<p>一起看这么个场景，大致上是下面这样，是 clojure 的代码。但是请不要担心，它非常短也非常简单：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; 定义一个 clojure 动态绑定的变量，实际就是个 Java ThreadLocal 对象</span></div><div class="line">(<span class="name"><span class="builtin-name">defonce</span></span> ^<span class="symbol">:dynamic</span> *utc* <span class="literal">false</span>)</div><div class="line"></div><div class="line"><span class="comment">;; 处理某 Http 请求的函数, 参数 req 内是用户传来的 Key -&gt; Value 格式的参数</span></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> some-http-handler-function [req]</div><div class="line">  <span class="comment">;; 首先需要从 req 内读取 API 版本信息 所有请求都会有这个参数</span></div><div class="line">  <span class="comment">;; 如果 API 版本是 1.1 则认为使用的是 utc 时间，所以给 *utc* 变量绑定一个 true 值</span></div><div class="line">  (<span class="name">binding</span> [*utc* (<span class="name"><span class="builtin-name">=</span></span> (<span class="symbol">:api-version</span> req) <span class="string">"1.1"</span>)]</div><div class="line">    <span class="comment">;; 绑定好 *utc* 后，开始处理 req 请求，process 返回值作为 Http 请求的结果</span></div><div class="line">    (<span class="name">process</span> req))</div></pre></td></tr></table></figure>
<p><code>some-http-handler-function</code> 是一个处理 Http 请求的函数，这个 Http 请求的 content-type 是 JSON。Server 收到请求后会将 body 内的 JSON 参数转换为 Key -&gt; Value 的 map 当做 <code>req</code> 参数传入 <code>some-http-handler-function</code> 函数做处理。</p>
<p>我们的 Http 接口要求请求中必须带着一些时间参数，并且时间参数须是符合 iso8601 格式的字符串，形如 2017-09-23T12:15:42.972Z。我们的 API 分为很多版本，1.1 版本之前的 API 没有对用户提供的这个时间参数的时区做约定，所以我们默认以当前服务器所在时区来解析用户传来的时间参数。1.1 版本之后的 API，我们跟用户约定时间参数必须是 UTC 时间，服务器也就直接以 UTC 时间来解析时间参数，从而不再有时区差异问题。</p>
<p>因为相同的 <code>some-http-handler-function</code> 函数，要兼容处理 1.1 版本 API 请求和老版本 API 请求，所以要在请求中带着 API 版本信息，并在收到请求后，根据 req 中的 API 版本信息，判断是否使用 UTC 时间。因为处理请求的函数有多层嵌套，比如 <code>(process req)</code> 可能调用 <code>(do-process req)</code>、<code>(do-after-do-process req)</code>等等，又不想让所有嵌套的函数调用都带着是否使用的 UTC 时间的参数，就简单的将是否使用 UTC 时间这个事情记录在一个动态绑定的 <code>*utc*</code> 参数上。</p>
<p>如果不了解 clojure，可以将 <code>*utc*</code> 简单理解为一个全局的 Java ThreadLocal 对象，同一个线程存入一个值后，比如将 <code>*utc*</code> 这个字符串绑定为 true 后，在该线程后续调用的所有函数、方法内，都能直接拿到 <code>*utc*</code> 参数的值，从而不用在所有该线程调用的函数、方法内都带着 <code>*utc*</code> 参数。让代码简单一些。</p>
<p>最初 <code>(process req)</code> 是个同步的调用，绑定完 <code>*utc*</code> 参数的主线程会完成 <code>process</code> 函数内所有逻辑，完成 Http 请求的处理并负责将结果发给用户。但后来为了隔离，将 <code>process</code> 函数内增加了线程池，会从线程池找一个空闲线程来实际处理 Http 请求，当前主线程会 Block 住等待 <code>process</code> 执行结果。由于 Java ThreadLocal 对象是不能在线程之间传递的，所以主线程虽然绑定了 <code>*utc*</code> 参数，但是 <code>process</code> 内的业务线程并不知道这个事情，于是出现即使在处理 1.1 版本 API 的请求时，所有时间参数也均采用服务器本地时区来解析，而不是 UTC 来解析，造成了 Bug。</p>
<p>这就是我遇到的线程之间传递 ThreadLocal 对象需求的来源。我们的解决办法很简单粗暴，就是将 <code>*utc*</code> 这个参数直接放在 <code>process</code> 函数的参数之中，等到 <code>process</code> 内的线程实际运行时，重新为线程池内实际执行 <code>process</code> 工作的业务线程绑定 <code>*utc*</code> 参数。</p>
<p>当时就在想如果有机制能在一些特定情况之下，让 ThreadLocal 对象绑定的 Value 在不同线程之间能共享，对上面这种场景处理就会比较方便。主线程将处理请求的任务交给业务线程之后，即使两个线程共享 <code>*utc*</code> 参数，但因为都不修改这个参数值，所以并不会引起问题。</p>
<p>下面我们看看这种 ThreadLocal 对象绑定值如何在不同线程之间传递。</p>
<h2 id="父子进程之间传递-ThreadLocal-对象"><a href="#父子进程之间传递-ThreadLocal-对象" class="headerlink" title="父子进程之间传递 ThreadLocal 对象"></a>父子进程之间传递 ThreadLocal 对象</h2><p>这个实际上 JDK 自己有实现，是 InheritableThreadLocal 类。慢慢介绍一下它的原理。</p>
<p>Thread 类内实际有两个 ThreadLocal.ThreadLocalMap，一个是给 ThreadLocal 使用的，还一个是给 InheritableThreadLocal 使用的。给 InheritableThreadLocal 使用的 ThreadLocalMap 特殊一些，在一个线程 fork 一个新的子线程的时候，父线程会检查自己 Thread 内为 InheritableThreadLocal 使用的 ThreadLocalMap 是否为空，不为空则将其拷贝给子线程的为 InheritableThreadLocal 使用的 ThreadLocalMap。Thread 的 init 可以看到这块逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</div><div class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</div><div class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</div></pre></td></tr></table></figure>
<p>ThreadLocal.createInheritedMap 会调用 ThreadLocalMap 的拷贝构造函数实现大致为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</div><div class="line">    Entry[] parentTable = parentMap.table;</div><div class="line">  <span class="keyword">int</span> len = parentTable.length;</div><div class="line">  setThreshold(len);</div><div class="line">  table = <span class="keyword">new</span> Entry[len];</div><div class="line"></div><div class="line">  <span class="keyword">for</span> each Entry e in parentTable &#123;</div><div class="line">        <span class="keyword">if</span> e != <span class="keyword">null</span> &#123; </div><div class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</div><div class="line">          <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">            Object value = key.childValue(e.value);</div><div class="line">                setKeyValueToThisThreadLocalMap(key, value);</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么一来创建子线程之后，父线程的给 InheritableThreadLocal 使用的 ThreadLocalMap 就在子线程中有了一个副本。默认情况下父子线程的 ThreadLocalMap 内的 key 都指向同一个 InheritableThreadLocal 对象，Value 也指向同一个 Value。从上面能看到子线程存储 ThreadLocalMap 的 Value 实际上是 key.childValue(e.value) 就是说能在使用 InheritableThreadLocal 的时候覆盖 childValue 方法从而根据父线程的 Value 提供子线程的 Value。</p>
<p>但是对于开篇那个问题的场景，InheritableThreadLocal 无法使用。在那个场景中，相当于是一个 Thread A 发配一个 Runnable 或者 Callable 到一个线程池中，让线程池内的线程去执行 <code>Runnable/Callable</code>。Thread A 和线程池内的线程并没有父子关系，所以 Thread A 不能将绑定的 InheritableThreadLocal 值传递给线程池内负责实际执行 <code>Runnable/Callable</code>的线程。</p>
<img src="/2017/09/25/transmittable-thread-local/transmittable-thread-local.png" alt="用 Runnable/Callable 传递 ThreadLocal" title="用 Runnable/Callable 传递 ThreadLocal">
<p>Thread A 传递给线程池内线程的只有 <code>Runnable/Callable</code>，所以如果想要实现将 ThreadA 的 ThreadLocal 值传递给线程池内实际负责执行 <code>Runnable/Callable</code> 的 Thread，就一定是需要在 <code>Runnalbe/Callable</code> 做文章，传递 <code>Runnable/Callable</code> 的时候将 Thread A 的 ThreadLocal 值存到 <code>Runnable/Callable</code> 中，之后线程池线程，比如是 Thread 1，在运行 <code>Runnable/Callable</code> 时从中读出这些 ThreadLocal 值并存入Thread 1 的 ThreadLocalMap 中，实现 ThreadLocal 对象值的传递。这也是 <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="external">GitHub - alibaba/transmittable-thread-local</a> 库最基础的实现原理。</p>
<p>感觉很多东西都是这样，仔细想想原理感觉不难，但难的是能想到这个点子。之前遇到开篇问题的时候只是想绕过的笨办法，没想想怎么从 ThreadLocal 原理上来解决这个问题。下面记录一下这个库的部分实现，但是这里不准备直接记录 transmittable thread local 是怎么实现，而是看看能不能在现有了解东西的基础上，一步一步推测出来它怎么实现。</p>
<h2 id="transmittable-thread-local"><a href="#transmittable-thread-local" class="headerlink" title="transmittable-thread-local"></a>transmittable-thread-local</h2><p>通过上面的描述，应该已对 transmittable thread local 的实现原理有个大致的猜想。首先是需要有个专门的 Runnable 或 Callable，用于读取原 Thread 的 ThreadLocal 对象及其值并存在 <code>Runnable/Callable</code>中，在执行 run 或者 call 的时候将存在 <code>Runnable/Callable</code> 中的 ThreadLocal 对象和值读出来，存入调用 run 或 call 的线程。</p>
<p>读取原 Thread 上所有的(或者说会发生这种线程间传递的) ThreadLocal 对象及其值比较麻烦，ThreadLocal 和 InheritableThreadLocal 都没有开放内部的 ThreadLocalMap，不能直接读取。所以要么自己完全实现一套 ThreadLocalMap 机制，像 Netty 的 FastThreadLocal 那样；要么就是自己实现 ThreadLocal 的子类，在每次调用 ThreadLocal 的 <code>set/get/remove</code> 等接口的时候，为 Thread 记录到底绑定了哪些需要发生线程间传递的 ThreadLocal 对象。后者更简单和更可靠一些，所以可能选择后者更稳妥，transmittable-thread-local 这个库也是这么做的。</p>
<p>通过 <code>Runnable/Callable</code> 传递 ThreadLocal 对象及其值的方法是有了，父子线程之间传递可以复用 InheritableThreadLocal 的实现，所以新的 TransmittableThreadLocal 对象需要继承 InheritableThreadLocal 从而获取它的父子线程间传递 ThreadLocal 对象及其值的能力。到目前为止，大致的类图如下：</p>
<img src="/2017/09/25/transmittable-thread-local/transmittable-thread-local2.png" alt="transmittable-thread-local 实现" title="transmittable-thread-local 实现">
<p>使用的时候必须使用使用 TransmittableThreadLocal，创建 Runnable 或 Callable 也必须使用 TtlCallable 或者 TtlRunnable。TransmittableThreadLocal 覆盖实现了 ThreadLocal 的 set、get、remove，实际存储 ThreadLocal 值的工作还是 ThreadLocal 父类完成，TransmittableThreadLocal 只是为每个使用它的 Thread 单独记录一份存储了哪些 TransmittableThreadLocal 对象。拿 set 来说就是这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>.set(value);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == value) removeValue();</div><div class="line">  <span class="keyword">else</span> addValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>addValue() 和 removeValue 都是将当前 TransmittableThreadLocal 对象存入 TransmittableThreadLocal 内一个 static 的并且是 InheritableThreadLocal 的 WeakHashMap 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder =</div><div class="line">    <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(parentValue);</div><div class="line">      &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!holder.get().containsKey(<span class="keyword">this</span>)) &#123;</div><div class="line">        holder.get().put(<span class="keyword">this</span>, <span class="keyword">null</span>); <span class="comment">// WeakHashMap supports null value.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于是和 Thread 绑定的所有 TransmittableThreadLocal 对象都保存在这个 holder 中，TransmittableThreadLocal 对应的 Value 则还是保存在 ThreadLocal 的 ThreadLocalMap 中。holder 只是为了记录当前 Thread 绑定了哪些 TransmittableThreadLocal 对象，好在 TtlRunnable 或 TtlCallable 构造的时候通过 holder 取出这些 TransmittableThreadLocal 存入 TtlRunnable 或 TtlCallable。</p>
<p>剩下的更多细节感觉就不用再多记录了，有兴趣的话可以下载这个库的代码看看。上面原理虽然看上去简单，但是这个库还在易用性上做了很多增强，还是值得看看值得使用一下的。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://ylgrgyq.github.io/2017/09/25/transmittable-thread-local/" data-id="cjagai4ux000ecowx833v9u31" class="article-share-link">Share</a><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a href="/2017/11/11/netty-resource-leack-detector/" class="pre">Netty 的资源泄露探测机制</a><a href="/2017/09/21/java-threadlocal/" class="next">Java ThreadLocal</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/Bug/" style="font-size: 15px;">Bug</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Others/" style="font-size: 15px;">Others</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/netty-resource-leack-detector/">Netty 的资源泄露探测机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/transmittable-thread-local/">线程之间传递 ThreadLocal 对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/java-threadlocal/">Java ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/12/idea-import-gradle-project/">Intellij IDEA 导入 Gradle 项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/linux-receive-packet-3/">Linux 网络协议栈收消息过程-TCP Protocol Layer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/24/linux-receive-packet-2/">Linux 网络协议栈收消息过程-Per CPU Backlog</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/23/linux-receive-packet-1/">Linux 网络协议栈收消息过程-Ring Buffer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/RTM-max-connections/">实时通信系统并发连接数测试时需要调整的各种参数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/tcp-time-wait/">TCP TIME-WAIT</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/18/tcp-backlog/">TCP Backlog</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">A Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>